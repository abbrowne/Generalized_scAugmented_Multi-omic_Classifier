---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 

```{r environment setup}

library(dplyr)
library(TCGAbiolinks)
library(DT)
library(purrr)
library(recount3)
library(DESeq2)
library(edgeR)
library(limma)
library(GSVA)
library(qusage)
library(org.Hs.eg.db)
library(AnnotationDbi)
library(rpart)
library(pdacR)
library(Seurat)
library(switchBox)
library(ncvreg)
library(stringr)
library(survival)
library(survminer)
library(ggplot2)

```

```{r get all TCGA PAAD expression}

##Use recount3 to retrieve expression data for TCGA PAAD and normalize using different approaches

human_projects <- available_projects()

tcga_paad_info = subset(
    human_projects,
    project == "PAAD" & file_source == "tcga" & project_type == "data_sources"
)

proj_info <- map(seq(nrow(tcga_paad_info)), ~tcga_paad_info[.x, ])

## create the RangedSummarizedExperiment. the create_rse function works on one row a time 

rse_tcga_paad <- map(proj_info, ~create_rse(.x))

#### Creating TPM from counts and transcript length
count2tpm<- function(rse){
    count_matrix <- rse@assays@data$raw_counts
    gene_length <- rse@rowRanges$bp_length
    reads_per_rpk <- count_matrix/gene_length
    per_mil_scale <- colSums(reads_per_rpk)/1000000
    tpm_matrix <- t(t(reads_per_rpk)/per_mil_scale)
    return(tpm_matrix)
}

getCountMatrix<- function(rse){
    count_matrix <- rse@assays@data$raw_counts
    return(count_matrix)
}

## convert raw count matrix per cancer type to TPM and subset to only the genes of interest 
tpm_data<- map(rse_tcga_paad, count2tpm)
count_data <- map(rse_tcga_paad, getCountMatrix)

## get the metadata column 
metadata<- map(rse_tcga_paad, ~.x@colData@listData %>% as.data.frame())

# bind the data matrix across cancer types together 
tpm_data2<- purrr::reduce(tpm_data, cbind)
count_data2 <- purrr::reduce(count_data,cbind)

## bind the metadata across cancer types together
metadata2<- purrr::reduce(metadata, rbind)

##Ensure idential ID naming across datasets and save them
rownames(metadata2) <- metadata2$tcga.gdc_cases.samples.submitter_id
colnames(count_data2) <- rownames(metadata2)
colnames(tpm_data2) <- rownames(metadata2)

dim(tpm_data2)
dim(count_data2)
dim(metadata2)

tpm_data2[1:5,1:5]
count_data2[1:5,1:5]
metadata2[1:5,1:5]

saveRDS(tpm_data2,file="E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_TPM_data.RDS")
saveRDS(count_data2,file="E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_count_data.RDS")
saveRDS(metadata2,file="E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_meta_data.RDS")

```

```{r load data}

#Load expression and metadata files
input_counts <- readRDS("E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_count_data.RDS")
input_counts <- input_counts[,order(colnames(input_counts))]
input_tpm <- readRDS("E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_TPM_data.RDS")
input_tpm <- input_tpm[,order(colnames(input_tpm))]
input_meta <- readRDS("E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_meta_data.RDS")
input_meta <- input_meta[order(rownames(input_meta)),]

##Load and add survival data to metadata
input_surv <- read.table("E:/Projects/Example_data/TCGA_PAAD/survival_PAAD_survival.txt",sep="\t",header=TRUE,row.names=1)
rownames(input_surv) <- paste0(rownames(input_surv),"A")
colnames(input_surv) <- paste0("Survival_",colnames(input_surv))
sum(rownames(input_surv) %in% rownames(input_meta))
sum(colnames(input_surv) %in% colnames(input_meta))
input_meta <- cbind(input_meta,input_surv[rownames(input_meta),])

##Replace . with _ for column names
names(input_meta) <- gsub("\\.", "_", names(input_meta))

##Reformat and factor primary sample type column used as covariate in modeling
input_meta$sample_type <- input_meta$tcga_cgc_sample_sample_type
input_meta$sample_type[input_meta$sample_type == "Primary Tumor"] <- "Tumor"
input_meta$sample_type[input_meta$sample_type == "Metastatic"] <- "Met"
input_meta$sample_type[input_meta$sample_type == "Solid Tissue Normal"] <- "Normal"
input_meta$sample_type <- factor(input_meta$sample_type,levels=c("Normal","Tumor","Met"))

### Check that sample names match in both files
all(colnames(input_counts) %in% rownames(input_meta))
all(colnames(input_counts) == rownames(input_meta))

##Filter non-expressed genes
keep <- rowSums(input_counts > 0) > 0
input_counts <- input_counts[keep,]
input_tpm <- input_tpm[keep,]

##Get HGNC symbols for remaining genes and replace ENSEMBL rownames
gene_ids <- rownames(input_counts)

# Remove version suffix if present
gene_ids_clean <- sub("\\..*", "", gene_ids)

# Connect to the Ensembl database
# You can specify an Ensembl release if needed, e.g., useEnsembl(biomart="ensembl", 
# version=109, dataset="hsapiens_gene_ensembl")
symbol_map <- mapIds(
    x         = org.Hs.eg.db,
    keys      = gene_ids_clean,
    column    = "SYMBOL",     # We want HGNC gene symbols
    keytype   = "ENSEMBL",    # Our keys are Ensembl gene IDs
    multiVals = "first"       # If multiple symbols map to one ID, take the first
)

##Replace ensembl IDs with symbols if not NA and not duplicated
temp_rownames <- ifelse(
    is.na(symbol_map[gene_ids_clean]),
    gene_ids_clean,
    symbol_map[gene_ids_clean]
)
rownames(input_counts) <- ifelse(
    duplicated(temp_rownames),
    gene_ids_clean,
    temp_rownames
)
rownames(input_tpm) <- rownames(input_counts)

##Derive CPM
lib_sizes <- colSums(input_counts)
input_cpm <- t(t(input_counts) / lib_sizes * 1e6)
saveRDS(input_cpm,file="E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_CPM.RDS")

##Perform edgeR TMM normalization
dge <- DGEList(counts = input_counts, group = input_meta$sample_type)
dge <- calcNormFactors(dge, method = "TMM")
input_cpmtmm <- cpm(dge, normalized.lib.sizes = TRUE)
saveRDS(input_cpmtmm,file="E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_TMM_normalized_cpm.RDS")

##Perform DESeq2 normalization
dds <- DESeqDataSetFromMatrix(countData = input_counts, colData = input_meta, design = ~ sample_type)

vsd <- vst(dds, blind = FALSE)
input_vst <- assay(vsd)

saveRDS(input_vst,file="E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_DESeq2_normalized_vst.RDS")

##Save all expression formats and metadata
input_expression_set <- list(log2CPM=log2(input_cpm+1),log2TPM=log2(input_tpm+1),log2TMM=log2(input_cpmtmm+1),VST=input_vst)
saveRDS(input_expression_set,file="E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_expression_set.RDS")
saveRDS(input_meta,file="E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_primary_meta.RDS")


```

```{r derive scores}

##Load expression set
input_expression_set <- readRDS("E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_expression_set.RDS")

##Load example GMTs relevant to TCGA PAAD
hp_gmt <- qusage::read.gmt("E:/Projects/Example_data/genesets/h.all.v2024.1.Hs.symbols.gmt")
pdac_genesets <- pdacR::gene_lists
pdac_genesets$Moffitt.Tumor <- NULL
pdac_genesets$Puleo.Centroids <- NULL
pdac_genesets$ICGC.SAM <- NULL
pdac_genesets$Moffitt.Top5s <- NULL
pdac_genesets$Moffitt.Top25s <- NULL
all_gmts <- c(hp_gmt,pdac_genesets)

##This geneset can be used to chromosomal locus estimates
#c1_gmt <- qusage::read.gmt("E:/Projects/Example_data/genesets/c1.all.v2024.1.Hs.symbols.gmt")

##Run GSVA on all included genesets to derive a score and save
input_gsva_set <- list(GSVA=list())#,ssGSEA=list())
for(temp_input_i in 1:length(input_expression_set)){
  temp_name <- names(input_expression_set)[[temp_input_i]]
  input_gsva_set$GSVA[[temp_name]] <- gsva(gsvaParam(input_expression_set[[temp_name]],all_gmts))
  #input_gsva_set$ssGSEA[[temp_name]] <- gsva(ssgseaParam(input_expression_set[[temp_name]],hp_gmt,normalize = FALSE))
}
saveRDS(input_gsva_set,file="E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_gsva_set.RDS")




```

```{r run survival cut tree analysis}

##Load metadata and GSVA scores and add them to metadata
input_meta <- readRDS("E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_primary_meta.RDS")
input_gsva_set <- readRDS("E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_gsva_set.RDS")
temp_gsva <- t(input_gsva_set$GSVA$log2CPM)[rownames(input_meta),]
colnames(temp_gsva) <- paste0("GSVA_",colnames(temp_gsva))
temp_meta <- cbind(input_meta,temp_gsva)

##Modified one entry with 0 for survival time that was causing an error
temp_meta$Survival_OS_time[temp_meta$Survival_OS_time == 0] <- 1

##Create survival formula for assessing all included GSVA scores in relation to overall survival
temp_formula <- as.formula(paste0("Surv(Survival_OS_time, Survival_OS) ~ ",paste(colnames(temp_meta)[grepl("GSVA_",colnames(temp_meta))],collapse = " + ")))

##Run and plot survival cutpoint analysis to identify the most prognostic covariates and cutpoints for the proposed survival model
fit <- rpart(temp_formula, data = temp_meta, method = "exp", control = rpart.control(cp=0.02,maxdepth=4,
                                                                                     minsplit = round(nrow(temp_meta)/5),
                                                                                     minbucket = round(nrow(temp_meta)/10)))

plot(fit,  uniform=TRUE,  main="Survival Tree")
text(fit, use.n=TRUE, all=TRUE, cex=.8)

```

```{r determine best signature celltype drivers with scRNAseq reference}

##Load PDAC scRNAseq reference atlas from Chijimatsu et al. paper
input_scData <- readRDS("E:/Projects/Cancer/PDAC Chijimatsu reconstruction/scDatasets/pk_all.rds")

##Load top gene sets from survival cutpoint analysis
my_gene_set1 <- all_gmts$Moffitt.F6_BasalLike.top100
my_gene_set2 <- all_gmts$CIBERSORT.Neutrophils
gene_set_list <- list("GSVA_Moffitt.F6_BasalLike.top250" = my_gene_set1,"CIBERSORT_Neutrophils" = my_gene_set2)

##Evaluate the top prognostic gene sets for their enrichment in a specific cell type in the PDAC scRNAseq atlas
seurat_obj <- input_scData
for(temp_i in 1:length(gene_set_list)){

  # Add module score to Seurat object
  seurat_obj <- AddModuleScore(
    object   = seurat_obj,
    features = list(gene_set_list[[temp_i]]),
    name     = "CustomGeneset"
  )
  
  temp_plot <- DimPlot(seurat_obj, group.by = "Cell_type")
  print(temp_plot)

  temp_plot <- FeaturePlot(
    object   = seurat_obj, 
    features = "CustomGeneset1", 
    pt.size  = 0.5
  ) + ggtitle(paste0("Module score for: ",names(gene_set_list)[temp_i]))
  print(temp_plot)

  temp_plot <- VlnPlot(
    object   = seurat_obj, 
    features = "CustomGeneset1", 
    group.by = "Cell_type"  # or your cell type annotation column
  ) + ggtitle(paste0("Module score for: ",names(gene_set_list)[temp_i]))
  print(temp_plot)

  temp_plot <- DotPlot(
    seurat_obj, 
    features  = gene_set_list[[temp_i]], 
    group.by  = "Cell_type"
  ) + RotatedAxis() + 
    ggtitle(paste0("Module score for: ",names(gene_set_list)[temp_i]))
  print(temp_plot)

  temp_plot <- RidgePlot(seurat_obj, features = "CustomGeneset1", group.by = "Cell_type") + 
    ggtitle(paste0("Module score for: ",names(gene_set_list)[temp_i]))
  print(temp_plot)
  
}

##Extract and save marker genes for cell types that showed enrichment of the top prognostic GSVA scores
temp_scMarkers <- list()
temp_scMarkers[["Ductal_cell_type_2"]] <- 
  FindMarkers(
    object        = input_scData,
    ident.1       = "Ductal cell type 2",       # cell type or cluster name
    only.pos      = TRUE,            # only keep genes positively enriched in "T cells"
    logfc.threshold = 1.5,          # filter out genes with low logFC
    min.pct       = 0.1              # filter out genes not expressed in at least 10% of T cells
  )

temp_scMarkers[["Macrophage_cell"]] <- 
  FindMarkers(
      object        = input_scData,
      ident.1       = "Macrophage cell",       # cell type or cluster name
      only.pos      = TRUE,            # only keep genes positively enriched in "T cells"
      logfc.threshold = 1.25,          # filter out genes with low logFC
      min.pct       = 0.1              # filter out genes not expressed in at least 10% of T cells
  )

saveRDS(temp_scMarkers,file="E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_exploratory_scMarkers.RDS")


```

```{r derive classifier for survival variables}

##Load metadata, GSVA scores, and expression data for TCGA PAAD
input_meta <- readRDS("E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_primary_meta.RDS")
input_gsva_set <- readRDS("E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_gsva_set.RDS")
input_expression_set <- readRDS("E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_expression_set.RDS")

##Add GSVA scores to metadata
temp_gsva <- t(input_gsva_set$GSVA$log2CPM)[rownames(input_meta),]
colnames(temp_gsva) <- paste0("GSVA_",colnames(temp_gsva))
temp_meta <- cbind(input_meta,temp_gsva)

##Define group based on top survival tree cutpoint results
temp_meta$CustomGroup_Moffitt_F6_BasalLike_Top100_High <- as.factor(temp_meta$GSVA_Moffitt.F6_BasalLike.top100 >= -0.3686)
temp_meta$CustomGroup_CIBERSORT_Neutrophils_High <- as.factor(temp_meta$GSVA_CIBERSORT.Neutrophils >= 0.03927)

##Use marker genes from scRNAseq as input to consider for top scoring pair classifier derivation
temp_scMarkers <- readRDS("E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_exploratory_scMarkers.RDS")
input_expr <- input_expression_set$log2TPM

###Run classification for Ductal cell type 2
temp_expr <- input_expr[rownames(input_expr) %in% rownames(temp_scMarkers$Ductal_cell_type_2),]

##Define group for classification and run switchBox function to identify pairs of genes that can be used to identify it
temp_group <- temp_meta$CustomGroup_Moffitt_F6_BasalLike_Top100_High
temp_TSP_result <- SWAP.KTSP.Train(temp_expr,temp_group,krange = 50,FilterFunc = NULL)

##Format gene pairs into binary matrix of comparisons for each sample to use in logistic regression
temp_resultMat <- list()
for(temp_i in 1:nrow(temp_TSP_result$TSPs)){
  temp_name <- paste0(temp_TSP_result$TSPs[temp_i,1],"_",temp_TSP_result$TSPs[temp_i,2])
  temp_resultMat[[temp_name]] <- as.vector(as.integer(temp_expr[temp_TSP_result$TSPs[temp_i,1],] > temp_expr[temp_TSP_result$TSPs[temp_i,2],]))
}
temp_resultMat <- as.data.frame(temp_resultMat,row.names = colnames(temp_expr))

##Perform logistic regression using top scoring pair result matrix and classification group to derive coefficients for each gene pair
test_ncv_result <- cv.ncvreg(temp_resultMat,
                             as.vector(as.integer(temp_meta$CustomGroup_Moffitt_F6_BasalLike_Top100_High)-1), alpha=0.5, nfolds = nrow(temp_resultMat))

temp_coefs <- coef(test_ncv_result)
temp_coefs <- temp_coefs[temp_coefs != 0]
temp_TSPs <- as.data.frame(list(geneA=unlist(lapply(names(temp_coefs)[-1], function(x) strsplit(x, "_")[[1]][1])),
                                geneB=unlist(lapply(names(temp_coefs)[-1], function(x) strsplit(x, "_")[[1]][2])),
                                coef=as.numeric(temp_coefs[-1])))

temp_TSP_classifier <- list(intercept=as.numeric(temp_coefs[1]),TSPs=temp_TSPs)

##Create function for classifier development

create_ncvTSP_classifier <- function(input_expression, input_group, input_scMarkers){
  temp_expr <- input_expression[rownames(input_expression) %in% input_scMarkers,]
  
  temp_TSP_result <- SWAP.KTSP.Train(temp_expr,as.factor(input_group),krange = 50,FilterFunc = NULL)

  ##Format gene pairs into binary matrix of comparisons for each sample to use in logistic regression
  temp_resultMat <- list()
  for(temp_i in 1:nrow(temp_TSP_result$TSPs)){
    temp_name <- paste0(temp_TSP_result$TSPs[temp_i,1],"_",temp_TSP_result$TSPs[temp_i,2])
    temp_resultMat[[temp_name]] <- as.vector(as.integer(temp_expr[temp_TSP_result$TSPs[temp_i,1],] > temp_expr[temp_TSP_result$TSPs[temp_i,2],]))
  }
  temp_resultMat <- as.data.frame(temp_resultMat,row.names = colnames(temp_expr))
  
  ##Perform logistic regression using top scoring pair result matrix and classification group to derive coefficients for each gene pair
  test_ncv_result <- cv.ncvreg(temp_resultMat,
                               input_group, 
                               alpha=0.5, nfolds = nrow(temp_resultMat))
  
  temp_coefs <- coef(test_ncv_result)
  temp_coefs <- temp_coefs[temp_coefs != 0]
  temp_TSPs <- as.data.frame(list(geneA=unlist(lapply(names(temp_coefs)[-1], function(x) strsplit(x, "_")[[1]][1])),
                                  geneB=unlist(lapply(names(temp_coefs)[-1], function(x) strsplit(x, "_")[[1]][2])),
                                  coef=as.numeric(temp_coefs[-1])))
  
  ##Derive recommended probability cutoff
  all_TSPs <- c(temp_TSPs$geneA,temp_TSPs$geneB)
  sub_expr <- input_expression[rownames(input_expression) %in% all_TSPs,]
  temp_TSPs <- temp_TSPs[temp_TSPs$geneA %in% rownames(sub_expr) & temp_TSPs$geneB %in% rownames(sub_expr),]
  
  temp_resultMat <- list()
  for(temp_i in 1:nrow(temp_TSPs)){
    temp_name <- paste0(temp_TSPs$geneA[temp_i],"_",temp_TSPs$geneB[temp_i])
    temp_resultMat[[temp_name]] <- as.vector(as.integer(sub_expr[temp_TSPs$geneA[temp_i],] > sub_expr[temp_TSPs$geneB[temp_i],]))
  }
  temp_resultMat <- as.data.frame(temp_resultMat,row.names = colnames(sub_expr))
  
  ### p = exp(x*coef) / (1 + exp(x*coef))
  temp_resultVector <- rowSums(t(t(temp_resultMat) * temp_TSPs$coef))
  temp_resultProb <- exp(temp_resultVector) / (1 + exp(temp_resultVector))
  all_cutoff_values <- seq(1,99)/100
  min_errors <- length(input_group)
  for(temp_cutoff_i in 1:length(all_cutoff_values)){
    temp_cutoff_value <- all_cutoff_values[temp_cutoff_i]
    temp_table <- table(input_group,temp_resultProb > temp_cutoff_value)
    if(nrow(temp_table) == 2 & ncol(temp_table) == 2){
      temp_errors <- sum(temp_table[1,2] + temp_table[2,1])
      if(temp_errors < min_errors){
        min_errors <- temp_errors
        best_cutoffs <- c(temp_cutoff_value)
      }else if(temp_errors == min_errors){
        best_cutoffs <- c(best_cutoffs,temp_cutoff_value)
      }
    }
  }
  
  ##Return classifier
  temp_TSP_classifier <- list(intercept=as.numeric(temp_coefs[1]),TSPs=temp_TSPs,best_cutoff_probs=best_cutoffs)
  return(temp_TSP_classifier)
}

##Run with function
all_classifiers <- list()

##Run for PDAC tumor
test_expression <- input_expr
test_group <- as.vector(as.integer(temp_meta$CustomGroup_Moffitt_F6_BasalLike_Top100_High)-1)
test_scMarkers <- rownames(temp_scMarkers$Ductal_cell_type_2)
all_classifiers[["PDAC_tumor"]] <- create_ncvTSP_classifier(test_expression, test_group, test_scMarkers)

##Run for PDAC macrophages
test_expression <- input_expr
test_group <- as.vector(as.integer(temp_meta$CustomGroup_CIBERSORT_Neutrophils_High)-1)
test_scMarkers <- rownames(temp_scMarkers$Macrophage_cell)
all_classifiers[["PDAC_macrophage"]] <- create_ncvTSP_classifier(test_expression, test_group, test_scMarkers)

##Compare classifier to existing Purist classifier

##Create function for applying TSP classifier with pairs and coefficients
apply_TSP_classifier <- function(input_expression, input_classifier, use_with_missing=FALSE, best_cutoff_probability=NULL){
  
  if(is.null(best_cutoff_probability)){
    best_cutoff_probability <- input_classifier$best_cutoff_probs[1]
  }
  ##Check for missing classifier genes in input dataset with option to drop those pairs
  all_TSPs <- c(input_classifier$TSPs$geneA,input_classifier$TSPs$geneB)
  if(sum(all_TSPs %in% rownames(input_expression)) < length(all_TSPs)){
    missing_TSPs <- all_TSPs[!(all_TSPs %in% rownames(input_expression))]
    cat(paste0("The following genes were missing from the input dataset:\n",
                 paste(missing_TSPs,collapse=", ")))
    cat(paste0("Full input dataset:\n"))
    print(input_classifier$TSPs)
    
    if(use_with_missing==TRUE){
      classifier_rows_to_drop <- c()
      for(temp_i in 1:nrow(input_classifier$TSPs)){
        if(!(input_classifier$TSPs$geneA[temp_i] %in% rownames(input_expression)) | 
           !(input_classifier$TSPs$geneB[temp_i] %in% rownames(input_expression))){
          classifier_rows_to_drop <- c(classifier_rows_to_drop,temp_i)
        }
      }
      input_classifier <- input_classifier$TSPs[-classifier_rows_to_drop,]
    }else{
      return(paste0("Error: Failed due to missing classifier genes in the input data"))
    }
  }
  
  all_TSPs <- c(input_classifier$TSPs$geneA,input_classifier$TSPs$geneB)
  temp_expr <- input_expression[rownames(input_expression) %in% all_TSPs,]
  
  temp_resultMat <- list()
  for(temp_i in 1:nrow(input_classifier$TSPs)){
    temp_name <- paste0(input_classifier$TSPs[temp_i,1],"_",input_classifier$TSPs[temp_i,2])
    temp_resultMat[[temp_name]] <- as.vector(as.integer(temp_expr[input_classifier$TSPs[temp_i,1],] > temp_expr[input_classifier$TSPs[temp_i,2],]))
  }
  temp_resultMat <- as.data.frame(temp_resultMat,row.names = colnames(temp_expr))
  
  ### p = exp(x*coef) / (1 + exp(x*coef))
  temp_resultVector <- rowSums(t(t(temp_resultMat) * input_classifier$TSPs$coef))
  temp_resultProb <- exp(temp_resultVector) / (1 + exp(temp_resultVector))
  temp_resultGroup <- as.factor(as.numeric(temp_resultProb > best_cutoff_probability))
  
  temp_classifier_result <- as.data.frame(list(prob=temp_resultProb,group=temp_resultGroup))
  rownames(temp_classifier_result) <- colnames(input_expression)
  return(temp_classifier_result)
}

#Load and format Purist classifier
load("E:/Projects/Cancer/fitteds_public_2019-02-12.Rdata")
temp_TSPs <- classifs$oct25_equivalent_freeze$TSPs
temp_coefs <- classifs$oct25_equivalent_freeze$fit$beta
temp_intercept <- temp_coefs[1]
temp_coefs <- temp_coefs[-1]
temp_TSPs <- temp_TSPs[temp_coefs != 0,]
temp_coefs <- temp_coefs[temp_coefs != 0]
temp_TSPs <- as.data.frame(list(geneA=temp_TSPs[,1], geneB=temp_TSPs[,2], coef=temp_coefs))
best_cutoffs <- c(0.5)

temp_TSP_classifier <- list(intercept=temp_intercept,TSPs=temp_TSPs,best_cutoff_probs=best_cutoffs)
all_classifiers[["Purist"]] <- temp_TSP_classifier

##Apply derived classifiers as well as published Purist classifier
all_classifier_results <- list()
for(temp_i in 1:length(all_classifiers)){
  temp_classifier_name <- names(all_classifiers)[temp_i]
  all_classifier_results[[temp_classifier_name]] <- apply_TSP_classifier(input_expr,all_classifiers[[temp_classifier_name]])
}

##Compare results to Purist in TCGA PAAD
temp_meta$test_surv_group1 <- as.factor(all_classifier_results$PDAC_tumor$group)
temp_meta$test_surv_group2 <- as.factor(all_classifier_results$Purist$group)

# Create the Surv object
surv_object <- Surv(time = temp_meta$Survival_OS_time, event = temp_meta$Survival_OS)

# Kaplan-Meier fit by 'group'
fit1 <- survfit(surv_object ~ test_surv_group1, data = temp_meta)
fit2 <- survfit(surv_object ~ test_surv_group2, data = temp_meta)

# Use ggsurvplot for a survival curve of both classifier groups
temp_plot1 <- ggsurvplot(fit1, 
              data = temp_meta,
              pval = TRUE,            # adds p-value for log-rank test
              conf.int = TRUE,        # adds confidence intervals
              risk.table = TRUE,      # add risk table at the bottom
              xlab = "Time",
              ylab = "Survival Probability",
              legend.title = "Group",
              legend.labs = levels(temp_meta$test_surv_group1),
              title = "Overall survival with scClassifier groups")

temp_plot2 <- ggsurvplot(fit2, 
              data = temp_meta,
              pval = TRUE,            # adds p-value for log-rank test
              conf.int = TRUE,        # adds confidence intervals
              risk.table = TRUE,      # add risk table at the bottom
              xlab = "Time",
              ylab = "Survival Probability",
              legend.title = "Group",
              legend.labs = levels(temp_meta$test_surv_group2),
              title = "Overall survival with Purist groups")

print(temp_plot1)
print(temp_plot2)


```

```{r next steps for planning}

###Create iterative loop for combined survival cutpoint and cell type enrichment analysis to loop until score with prognostic value and cell type enrichment are found
#For this, assess survival cutpoint 1 for cell type enrichment past a certain fold in a relevant atlas for the indication in question
#If cell type enrichment fails, rerun survival cutpoint analysis with variation in cp, minsplit, and minbucket variables
#For cell type enrichment, determine a certain fold enrichment over other cell types that is acceptable
#Option to also assess 2nd level of cuts for additional cell type specificity as with macrophages in PDAC

###Testing this iterative process below

check_sc_enrichment <- function(input_sc_dataset,input_gmts,input_geneset_name){
  seurat_obj <- NULL
  seurat_obj <- try(
    AddModuleScore(
      object   = input_sc_dataset,
      features = list(input_gmts[[input_geneset_name]]),
      name     = "CustomGeneset"
    ),
  silent = TRUE
  )
  if(!is.null(seurat_obj)){
    temp_result <- as.data.frame(seurat_obj@meta.data %>% 
                                 group_by(Cell_type) %>% 
                                 summarize(mean_ModuleScore = mean(CustomGeneset1)))
    temp_min <- min(temp_result$mean_ModuleScore)
    temp_result$norm_Module_score <- temp_result$mean_ModuleScore - temp_min
    temp_max_i <- which.max(temp_result$norm_Module_score)
    temp_max_value <- temp_result$norm_Module_score[temp_max_i]
    temp_max_cell_type <- temp_result$Cell_type[temp_max_i]
    comp_result <- temp_result$norm_Module_score[temp_result$Cell_type != temp_max_cell_type]
    temp_result <- list("max_cell_type" = temp_max_cell_type,
                        "max_module_score" = temp_max_value,
                        "other_module_scores" = comp_result)
    return(temp_result)
  }else{
    temp_result <- list("max_cell_type" = NA,
                        "max_module_score" = 0,
                        "other_module_scores" = c(100,100))
    return(temp_result)
  }
}

find_cellEnrichedPrognostic_scores <- function(input_expression,
                                               input_meta,
                                               input_outcome_time,
                                               input_outcome_result,
                                               input_sc_dataset,
                                               input_gmts,
                                               max_iterations=100,
                                               input_cp_set=c(0.05,0.02),
                                               initial_minsplit_fraction=0.4,
                                               initial_minbucket_fraction=0.4,
                                               minsplit_delta=0.1,
                                               minbucket_delta=0.1,
                                               max_prog_features_per_fit=5,
                                               max_enrichment_iterations=10,
                                               plot_name="initial_survplot"
                                               ){
  
  
  temp_meta <- input_meta
  
  ###Add GSVA scoring here for input expression data rather than meta with GSVA scores added
  cat(paste0("Running GSVA scoring on selected gene sets with included expression data.\n"))
  temp_gsva <- gsva(gsvaParam(input_expression,input_gmts))
  temp_gsva <- t(temp_gsva)[rownames(temp_meta),]
  colnames(temp_gsva) <- paste0("GSVA_",colnames(temp_gsva))
  temp_meta <- cbind(temp_meta,temp_gsva)
  
  ##Create survival formula for assessing all included GSVA scores in relation to overall survival
  temp_formula <- as.formula(paste0("Surv(",input_outcome_time,", ",input_outcome_result,") ~ ",
                                    paste(paste0("GSVA_",names(input_gmts)),collapse = " + ")))
  
  temp_minsplit <- round(nrow(temp_meta)*initial_minsplit_fraction)
  temp_minbucket <- round(nrow(temp_meta)*initial_minbucket_fraction)
  temp_cp_set <- input_cp_set
  
  flag_primary_cutpoint_sc_enrichment <- FALSE
  total_iterations <- 0
  temp_progFeature <- NULL
  temp_progCutoff <- NULL
  sub_gsva_columns <- colnames(temp_meta)[grepl("GSVA_",colnames(temp_meta))]
  cat(paste0("Running survival cutpoint analysis to identify the best prognostic feature and cutpoint with cell type association.\n"))
  while(flag_primary_cutpoint_sc_enrichment == FALSE & total_iterations <= max_iterations){
    if(total_iterations > 0){
      temp_minsplit <- round(nrow(temp_meta)*(initial_minsplit_fraction - minsplit_delta))
      temp_minbucket <- round(nrow(temp_meta)*(initial_minsplit_fraction - minbucket_delta))
      temp_formula <- as.formula(paste0("Surv(",input_outcome_time,", ",input_outcome_result,") ~ ",
                                          paste(sub_gsva_columns,collapse = " + ")))
    }
    for(temp_cp_i in 1:length(temp_cp_set)){
      temp_cp <- temp_cp_set[temp_cp_i]
      temp_fit <- rpart(temp_formula, data = temp_meta, method = "exp", 
                         control = rpart.control(cp=temp_cp,
                                                 maxdepth=1,
                                                 minsplit = temp_minsplit,
                                                 minbucket = temp_minbucket))
      if(length(names(temp_fit$variable.importance)) > 0){
        for(temp_prog_feature_i in 1:min(max_prog_features_per_fit,length(names(temp_fit$variable.importance)))){
          temp_progFeature <- names(temp_fit$variable.importance)[temp_prog_feature_i]
          temp_progCutoff <- temp_fit$splits[temp_progFeature,"index"]
          cat(paste0("Testing cp ",temp_cp," minsplit ",temp_minsplit," and minbucket ",temp_minbucket," with prog feature ",temp_prog_feature_i," : ",temp_progFeature,"\n"))
          temp_meta$test_surv_group <- as.factor(temp_meta[,temp_progFeature] < temp_progCutoff)
          temp_surv_formula <- as.formula(paste0("Surv(",input_outcome_time,", ",input_outcome_result,") ~ test_surv_group"))
          fit_cox <- coxph(temp_surv_formula, data = temp_meta)
          temp_summary <- summary(fit_cox)
          print(temp_summary)
          temp_coxph_pval <- as.numeric(temp_summary$waldtest["pvalue"])
          if(temp_coxph_pval < 0.05){
            input_geneset_name <- str_replace(temp_progFeature,"GSVA_","")
            comp_result <- check_sc_enrichment(input_sc_dataset,input_gmts,input_geneset_name)
            if(sum(comp_result$max_module_score >= comp_result$other_module_scores*2) == length(comp_result$other_module_scores)){
              flag_primary_cutpoint_sc_enrichment <- TRUE
              temp_survFit <- eval(bquote(
                  survfit(.(as.formula(
                    paste0("Surv(", input_outcome_time, ", ", input_outcome_result, ") ~ test_surv_group")
                  )), data = .(temp_meta))
                ))
              temp_best_surv_plot <- ggsurvplot(temp_survFit, data = temp_meta,
                pval = TRUE,            # adds p-value for log-rank test
                conf.int = TRUE,        # adds confidence intervals
                risk.table = TRUE,      # add risk table at the bottom
                xlab = "Time",
                ylab = "Survival Probability",
                legend.title = paste0(temp_progFeature, " < ",round(temp_progCutoff,3)),
                legend.labs = levels(temp_meta$test_surv_group))
              pdf(paste0("E:/Projects/BioApp_1/Example_data/TCGA_PAAD/",plot_name,".pdf"))
              print(temp_best_surv_plot)
              dev.off()
              temp_max_cell_type <- comp_result$max_cell_type
              break
            }
          }
          sub_gsva_columns <- sub_gsva_columns[sub_gsva_columns != temp_progFeature]
          total_iterations <- total_iterations + 1
        }
      }
      if(flag_primary_cutpoint_sc_enrichment == TRUE){
        break
      }
      sub_gsva_columns <- sub_gsva_columns[sub_gsva_columns != temp_progFeature]
    }
    sub_gsva_columns <- sub_gsva_columns[sub_gsva_columns != temp_progFeature]
  }
  
  if(flag_primary_cutpoint_sc_enrichment == TRUE){
    
    cat(paste0("Running single cell marker derivation to obtain a marker list between 500 and 1000 genes in size.\n"))
    
    temp_thresholdFC <- 1.5
    temp_scMarker_size <- 0
    temp_scMarkers <- NULL
    enrichment_iterations <- 0
    while((temp_scMarker_size < 500 | temp_scMarker_size > 1000) & enrichment_iterations < max_enrichment_iterations){
      temp_scMarkers <- FindMarkers(
        object        = input_sc_dataset,
        ident.1       = temp_max_cell_type,       # cell type or cluster name
        only.pos      = TRUE,            # only keep genes positively enriched in "T cells"
        logfc.threshold = temp_thresholdFC,          # filter out genes with low logFC
        min.pct       = 0.1              # filter out genes not expressed in at least 10% of T cells
        )
      temp_scMarker_size <- nrow(temp_scMarkers)
      if(temp_scMarker_size > 1000){
        temp_thresholdFC <- temp_thresholdFC * 1.1
      }else if(temp_scMarker_size < 500){
        temp_thresholdFC <- temp_thresholdFC * 0.5
      }
      enrichment_iterations <- enrichment_iterations + 1
    }
    if(enrichment_iterations == max_enrichment_iterations){
      cat(paste0("Failed to identify sufficient numbers of enriched markers for the cell type associating with the identified prognostic feature.\n",
                 "The best obtained marker list will be returned despite being outside the optimal range of approximately 500-1000 genes.\n"))
    }
    final_prog_info <- list(final_meta=temp_meta,
                            final_progFeature=temp_progFeature,
                            final_progCutoff=temp_progCutoff,
                            final_progGroup=as.factor(as.numeric(temp_meta[,temp_progFeature] < temp_progCutoff)),
                            #final_survPlot=temp_best_surv_plot,
                            final_cp=temp_cp,
                            final_minsplit=temp_minsplit,
                            final_minbucket=temp_minbucket,
                            final_enriched_cellType=temp_max_cell_type,
                            final_scMarkers=rownames(temp_scMarkers),
                            final_scMarker_enrichment_threshold=temp_thresholdFC)
    return(final_prog_info)
  }else{
    temp_message <- paste0("Failed to identify meaningful prognostic groups for a score showing cell type enrichment.\n")
    return(temp_message)
  }
}

##Load metadata and GSVA scores and add them to metadata
test_sc_dataset <- readRDS("E:/Projects/Cancer/PDAC Chijimatsu reconstruction/scDatasets/pk_all.rds")

input_expression_set <- readRDS("E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_expression_set.RDS")
test_expression <- input_expression_set$log2TPM

test_outcome_time <- "Survival_OS_time"
test_outcome_result <- "Survival_OS"

test_meta <- readRDS("E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_primary_meta.RDS")

##Modified one entry with 0 for survival time that was causing an error
test_meta$Survival_OS_time[test_meta$Survival_OS_time == 0] <- 1

##Load example GMTs relevant to TCGA PAAD
hp_gmt <- qusage::read.gmt("E:/Projects/Example_data/genesets/h.all.v2024.1.Hs.symbols.gmt")
pdac_genesets <- pdacR::gene_lists
pdac_genesets$Moffitt.Tumor <- NULL
pdac_genesets$Puleo.Centroids <- NULL
pdac_genesets$ICGC.SAM <- NULL
pdac_genesets$Moffitt.Top5s <- NULL
pdac_genesets$Moffitt.Top25s <- NULL
all_gmts <- c(hp_gmt,pdac_genesets)
test_gmts <- all_gmts

test_result <- find_cellEnrichedPrognostic_scores(test_expression,test_meta,test_outcome_time,test_outcome_result,test_sc_dataset,test_gmts)
saveRDS(test_result,file="E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_exploratory_cellEnrichedPrognostic_score_results.RDS")

#alt_gmts <- test_gmts
#alt_gmts[[str_replace(test_result$final_progFeature,"GSVA_","")]] <- NULL
#alt_meta1 <- test_meta[test_meta[,test_result$final_progFeature] < test_result$final_progCutoff,]
#alt_result1 <- find_cellEnrichedPrognostic_scores(alt_meta1,test_outcome_time,test_outcome_result,test_sc_dataset,alt_gmts)
#alt_meta2 <- test_meta[test_meta[,test_result$final_progFeature] >= test_result$final_progCutoff,]
#alt_result2 <- find_cellEnrichedPrognostic_scores(alt_meta2,test_outcome_time,test_outcome_result,test_sc_dataset,alt_gmts)

###Next up: link scEnriched prognostic scores and groups with classifier derivation functions
test_result <- readRDS("E:/Projects/Example_data/TCGA_PAAD/TCGA_PAAD_exploratory_cellEnrichedPrognostic_score_results.RDS")

#temp_meta <- test_result$final_meta
#temp_meta$test_progGroup <- as.factor(as.numeric(temp_meta[,test_result$final_progFeature] < test_result$final_progCutoff))

test_classifier_result <- create_ncvTSP_classifier(test_expression, test_result$final_progGroup, test_result$final_scMarkers)

test_classifier_calls <- apply_TSP_classifier(test_expression,test_classifier_result)

##Check results
table(test_classifier_calls$group,test_result$final_progGroup)

test_result$final_meta$test_surv_group <- test_classifier_calls$group

# Create the Surv object
surv_object <- Surv(time = test_result$final_meta[,test_outcome_time], event = test_result$final_meta[,test_outcome_result])
                    
# Kaplan-Meier fit by 'group'
fit1 <- survfit(surv_object ~ test_surv_group, data = test_result$final_meta)

# Use ggsurvplot for a survival curve of both classifier groups
temp_plot1 <- ggsurvplot(fit1, 
                         data = test_result$final_meta,
                         pval = TRUE,            # adds p-value for log-rank test
                         conf.int = TRUE,        # adds confidence intervals
                         risk.table = TRUE,      # add risk table at the bottom
                         xlab = "Time",
                         ylab = "Survival Probability",
                         legend.title = "Group",
                         legend.labs = levels(test_result$final_meta$test_surv_group),
                         title = "Overall survival with scClassifier groups")

print(temp_plot1)

##Try iterating on subgroups from first classifier

sub_result1 <- find_cellEnrichedPrognostic_scores(test_expression[,test_classifier_calls$group == 1],
                                                  test_result$final_meta[test_classifier_calls$group == 1,!grepl("GSVA_",colnames(test_result$final_meta))],
                                                  test_outcome_time,
                                                  test_outcome_result,
                                                  test_sc_dataset,
                                                  test_gmts)
sub_classifier_result1 <- create_ncvTSP_classifier(test_expression[,test_classifier_calls$group == 1], 
                                                   sub_result1$final_progGroup, 
                                                   sub_result1$final_scMarkers)

sub_classifier_calls1 <- apply_TSP_classifier(test_expression[,test_classifier_calls$group == 1],
                                              sub_classifier_result1)

sub_result1$final_meta$test_surv_group <- sub_classifier_calls1$group

# Create the Surv object
surv_object1 <- Surv(time = sub_result1$final_meta[,test_outcome_time], event = sub_result1$final_meta[,test_outcome_result])
                    
# Kaplan-Meier fit by 'group'
sub_fit1 <- survfit(surv_object1 ~ test_surv_group, data = sub_result1$final_meta)

# Use ggsurvplot for a survival curve of both classifier groups
sub_plot1 <- ggsurvplot(sub_fit1, 
                         data = sub_result1$final_meta,
                         pval = TRUE,            # adds p-value for log-rank test
                         conf.int = TRUE,        # adds confidence intervals
                         risk.table = TRUE,      # add risk table at the bottom
                         xlab = "Time",
                         ylab = "Survival Probability",
                         legend.title = "Group",
                         legend.labs = levels(sub_result1$final_meta$test_surv_group),
                         title = "Overall survival with scClassifier groups")

print(sub_plot1)

##

sub_result0 <- find_cellEnrichedPrognostic_scores(test_expression[,test_classifier_calls$group == 0],
                                                  test_result$final_meta[test_classifier_calls$group == 0,!grepl("GSVA_",colnames(test_result$final_meta))],
                                                  test_outcome_time,
                                                  test_outcome_result,
                                                  test_sc_dataset,
                                                  test_gmts)
sub_classifier_result0 <- create_ncvTSP_classifier(test_expression[,test_classifier_calls$group == 0], 
                                                   sub_result0$final_progGroup, 
                                                   sub_result0$final_scMarkers)

sub_classifier_calls0 <- apply_TSP_classifier(test_expression[,test_classifier_calls$group == 0],
                                              sub_classifier_result0)

sub_result0$final_meta$test_surv_group <- sub_result0$final_progGroup

# Create the Surv object
surv_object0 <- Surv(time = sub_result0$final_meta[,test_outcome_time], event = sub_result0$final_meta[,test_outcome_result])
                    
# Kaplan-Meier fit by 'group'
sub_fit0 <- survfit(surv_object0 ~ test_surv_group, data = sub_result0$final_meta)

# Use ggsurvplot for a survival curve of both classifier groups
sub_plot0 <- ggsurvplot(sub_fit0, 
                         data = sub_result0$final_meta,
                         pval = TRUE,            # adds p-value for log-rank test
                         conf.int = TRUE,        # adds confidence intervals
                         risk.table = TRUE,      # add risk table at the bottom
                         xlab = "Time",
                         ylab = "Survival Probability",
                         legend.title = "Group",
                         legend.labs = levels(sub_result1$final_meta$test_surv_group),
                         title = "Overall survival with scClassifier groups")

print(sub_plot0)


##Test classifier with a different PDAC dataset
human_projects <- available_projects()

tcga_paad_info = subset(
    human_projects,
    project == "PAAD" & file_source == "tcga" & project_type == "data_sources"
)

proj_info <- map(seq(nrow(tcga_paad_info)), ~tcga_paad_info[.x, ])

## create the RangedSummarizedExperiment. the create_rse function works on one row a time 

rse_tcga_paad <- map(proj_info, ~create_rse(.x))

#### Creating TPM from counts and transcript length
count2tpm<- function(rse){
    count_matrix <- rse@assays@data$raw_counts
    gene_length <- rse@rowRanges$bp_length
    reads_per_rpk <- count_matrix/gene_length
    per_mil_scale <- colSums(reads_per_rpk)/1000000
    tpm_matrix <- t(t(reads_per_rpk)/per_mil_scale)
    return(tpm_matrix)
}

getCountMatrix<- function(rse){
    count_matrix <- rse@assays@data$raw_counts
    return(count_matrix)
}

## convert raw count matrix per cancer type to TPM and subset to only the genes of interest 
tpm_data<- map(rse_tcga_paad, count2tpm)
count_data <- map(rse_tcga_paad, getCountMatrix)

## get the metadata column 
metadata<- map(rse_tcga_paad, ~.x@colData@listData %>% as.data.frame())

# bind the data matrix across cancer types together 
tpm_data2<- purrr::reduce(tpm_data, cbind)
count_data2 <- purrr::reduce(count_data,cbind)

## bind the metadata across cancer types together
metadata2<- purrr::reduce(metadata, rbind)

##Ensure idential ID naming across datasets and save them
rownames(metadata2) <- metadata2$tcga.gdc_cases.samples.submitter_id
colnames(count_data2) <- rownames(metadata2)
colnames(tpm_data2) <- rownames(metadata2)

dim(tpm_data2)
dim(count_data2)
dim(metadata2)

tpm_data2[1:5,1:5]
count_data2[1:5,1:5]
metadata2[1:5,1:5]

####Next up: explore classifier genes with RummaGEO



```

```{r run workflow with additional datasets}

###Load functions

check_sc_enrichment <- function(input_sc_dataset,input_gmts,input_geneset_name){
  seurat_obj <- NULL
  seurat_obj <- try(
    AddModuleScore(
      object   = input_sc_dataset,
      features = list(input_gmts[[input_geneset_name]]),
      name     = "CustomGeneset"
    ),
  silent = TRUE
  )
  if(!is.null(seurat_obj)){
    temp_result <- as.data.frame(seurat_obj@meta.data %>% 
                                 group_by(Cell_type) %>% 
                                 summarize(mean_ModuleScore = mean(CustomGeneset1)))
    temp_min <- min(temp_result$mean_ModuleScore)
    temp_result$norm_Module_score <- temp_result$mean_ModuleScore - temp_min
    temp_max_i <- which.max(temp_result$norm_Module_score)
    temp_max_value <- temp_result$norm_Module_score[temp_max_i]
    temp_max_cell_type <- temp_result$Cell_type[temp_max_i]
    comp_result <- temp_result$norm_Module_score[temp_result$Cell_type != temp_max_cell_type]
    temp_result <- list("max_cell_type" = temp_max_cell_type,
                        "max_module_score" = temp_max_value,
                        "other_module_scores" = comp_result)
    return(temp_result)
  }else{
    temp_result <- list("max_cell_type" = NA,
                        "max_module_score" = 0,
                        "other_module_scores" = c(100,100))
    return(temp_result)
  }
}

find_cellEnrichedPrognostic_scores <- function(input_expression,
                                               input_meta,
                                               input_outcome_time,
                                               input_outcome_result,
                                               input_sc_dataset,
                                               input_gmts,
                                               max_iterations=100,
                                               input_cp_set=c(0.05,0.02),
                                               initial_minsplit_fraction=0.4,
                                               initial_minbucket_fraction=0.4,
                                               minsplit_delta=0.1,
                                               minbucket_delta=0.1,
                                               max_prog_features_per_fit=5,
                                               max_enrichment_iterations=10,
                                               plot_name="initial_survplot"
                                               ){
  
  
  temp_meta <- input_meta
  
  ###Add GSVA scoring here for input expression data rather than meta with GSVA scores added
  cat(paste0("Running GSVA scoring on selected gene sets with included expression data.\n"))
  temp_gsva <- gsva(gsvaParam(input_expression,input_gmts))
  temp_gsva <- t(temp_gsva)[rownames(temp_meta),]
  colnames(temp_gsva) <- paste0("GSVA_",colnames(temp_gsva))
  temp_meta <- cbind(temp_meta,temp_gsva)
  
  ##Create survival formula for assessing all included GSVA scores in relation to overall survival
  temp_formula <- as.formula(paste0("Surv(",input_outcome_time,", ",input_outcome_result,") ~ ",
                                    paste(paste0("GSVA_",names(input_gmts)),collapse = " + ")))
  
  temp_minsplit <- round(nrow(temp_meta)*initial_minsplit_fraction)
  temp_minbucket <- round(nrow(temp_meta)*initial_minbucket_fraction)
  temp_cp_set <- input_cp_set
  
  flag_primary_cutpoint_sc_enrichment <- FALSE
  total_iterations <- 0
  temp_progFeature <- NULL
  temp_progCutoff <- NULL
  sub_gsva_columns <- colnames(temp_meta)[grepl("GSVA_",colnames(temp_meta))]
  cat(paste0("Running survival cutpoint analysis to identify the best prognostic feature and cutpoint with cell type association.\n"))
  while(flag_primary_cutpoint_sc_enrichment == FALSE & total_iterations <= max_iterations){
    if(total_iterations > 0){
      temp_minsplit <- round(nrow(temp_meta)*(initial_minsplit_fraction - minsplit_delta))
      temp_minbucket <- round(nrow(temp_meta)*(initial_minsplit_fraction - minbucket_delta))
      temp_formula <- as.formula(paste0("Surv(",input_outcome_time,", ",input_outcome_result,") ~ ",
                                          paste(sub_gsva_columns,collapse = " + ")))
    }
    for(temp_cp_i in 1:length(temp_cp_set)){
      temp_cp <- temp_cp_set[temp_cp_i]
      temp_fit <- rpart(temp_formula, data = temp_meta, method = "exp", 
                         control = rpart.control(cp=temp_cp,
                                                 maxdepth=1,
                                                 minsplit = temp_minsplit,
                                                 minbucket = temp_minbucket))
      if(length(names(temp_fit$variable.importance)) > 0){
        for(temp_prog_feature_i in 1:min(max_prog_features_per_fit,length(names(temp_fit$variable.importance)))){
          temp_progFeature <- names(temp_fit$variable.importance)[temp_prog_feature_i]
          temp_progCutoff <- temp_fit$splits[temp_progFeature,"index"]
          cat(paste0("Testing cp ",temp_cp," minsplit ",temp_minsplit," and minbucket ",temp_minbucket," with prog feature ",temp_prog_feature_i," : ",temp_progFeature,"\n"))
          temp_meta$test_surv_group <- as.factor(temp_meta[,temp_progFeature] < temp_progCutoff)
          temp_surv_formula <- as.formula(paste0("Surv(",input_outcome_time,", ",input_outcome_result,") ~ test_surv_group"))
          fit_cox <- coxph(temp_surv_formula, data = temp_meta)
          temp_summary <- summary(fit_cox)
          print(temp_summary)
          temp_coxph_pval <- as.numeric(temp_summary$waldtest["pvalue"])
          if(temp_coxph_pval < 0.05){
            input_geneset_name <- str_replace(temp_progFeature,"GSVA_","")
            comp_result <- check_sc_enrichment(input_sc_dataset,input_gmts,input_geneset_name)
            if(sum(comp_result$max_module_score >= comp_result$other_module_scores*2) == length(comp_result$other_module_scores)){
              flag_primary_cutpoint_sc_enrichment <- TRUE
              temp_survFit <- eval(bquote(
                  survfit(.(as.formula(
                    paste0("Surv(", input_outcome_time, ", ", input_outcome_result, ") ~ test_surv_group")
                  )), data = .(temp_meta))
                ))
              temp_best_surv_plot <- ggsurvplot(temp_survFit, data = temp_meta,
                pval = TRUE,            # adds p-value for log-rank test
                conf.int = TRUE,        # adds confidence intervals
                risk.table = TRUE,      # add risk table at the bottom
                xlab = "Time",
                ylab = "Survival Probability",
                legend.title = paste0(temp_progFeature, " < ",round(temp_progCutoff,3)),
                legend.labs = levels(temp_meta$test_surv_group))
              pdf(paste0("E:/Projects/BioApp_1/Example_data/TCGA_PAAD/",plot_name,".pdf"))
              print(temp_best_surv_plot)
              dev.off()
              temp_max_cell_type <- comp_result$max_cell_type
              break
            }
          }
          sub_gsva_columns <- sub_gsva_columns[sub_gsva_columns != temp_progFeature]
          total_iterations <- total_iterations + 1
        }
      }
      if(flag_primary_cutpoint_sc_enrichment == TRUE){
        break
      }
      sub_gsva_columns <- sub_gsva_columns[sub_gsva_columns != temp_progFeature]
    }
    sub_gsva_columns <- sub_gsva_columns[sub_gsva_columns != temp_progFeature]
  }
  
  if(flag_primary_cutpoint_sc_enrichment == TRUE){
    
    cat(paste0("Running single cell marker derivation to obtain a marker list between 500 and 1000 genes in size.\n"))
    
    temp_thresholdFC <- 1.5
    temp_scMarker_size <- 0
    temp_scMarkers <- NULL
    enrichment_iterations <- 0
    while((temp_scMarker_size < 500 | temp_scMarker_size > 1000) & enrichment_iterations < max_enrichment_iterations){
      temp_scMarkers <- FindMarkers(
        object        = input_sc_dataset,
        ident.1       = temp_max_cell_type,       # cell type or cluster name
        only.pos      = TRUE,            # only keep genes positively enriched in "T cells"
        logfc.threshold = temp_thresholdFC,          # filter out genes with low logFC
        min.pct       = 0.1              # filter out genes not expressed in at least 10% of T cells
        )
      temp_scMarker_size <- nrow(temp_scMarkers)
      if(temp_scMarker_size > 1000){
        temp_thresholdFC <- temp_thresholdFC * 1.1
      }else if(temp_scMarker_size < 500){
        temp_thresholdFC <- temp_thresholdFC * 0.5
      }
      enrichment_iterations <- enrichment_iterations + 1
    }
    if(enrichment_iterations == max_enrichment_iterations){
      cat(paste0("Failed to identify sufficient numbers of enriched markers for the cell type associating with the identified prognostic feature.\n",
                 "The best obtained marker list will be returned despite being outside the optimal range of approximately 500-1000 genes.\n"))
    }
    final_prog_info <- list(final_meta=temp_meta,
                            final_progFeature=temp_progFeature,
                            final_progCutoff=temp_progCutoff,
                            final_progGroup=as.factor(as.numeric(temp_meta[,temp_progFeature] < temp_progCutoff)),
                            #final_survPlot=temp_best_surv_plot,
                            final_cp=temp_cp,
                            final_minsplit=temp_minsplit,
                            final_minbucket=temp_minbucket,
                            final_enriched_cellType=temp_max_cell_type,
                            final_scMarkers=rownames(temp_scMarkers),
                            final_scMarker_enrichment_threshold=temp_thresholdFC)
    return(final_prog_info)
  }else{
    temp_message <- paste0("Failed to identify meaningful prognostic groups for a score showing cell type enrichment.\n")
    return(temp_message)
  }
}

create_ncvTSP_classifier <- function(input_expression, input_group, input_scMarkers){
    temp_expr <- input_expression[rownames(input_expression) %in% input_scMarkers,]
    
    temp_TSP_result <- SWAP.KTSP.Train(temp_expr,as.factor(input_group),krange = 50,FilterFunc = NULL)
    
    ##Format gene pairs into binary matrix of comparisons for each sample to use in logistic regression
    temp_resultMat <- list()
    for(temp_i in 1:nrow(temp_TSP_result$TSPs)){
        temp_name <- paste0(temp_TSP_result$TSPs[temp_i,1],"_",temp_TSP_result$TSPs[temp_i,2])
        temp_resultMat[[temp_name]] <- as.vector(as.integer(temp_expr[temp_TSP_result$TSPs[temp_i,1],] > temp_expr[temp_TSP_result$TSPs[temp_i,2],]))
    }
    temp_resultMat <- as.data.frame(temp_resultMat,row.names = colnames(temp_expr))
    
    ##Perform logistic regression using top scoring pair result matrix and classification group to derive coefficients for each gene pair
    test_ncv_result <- cv.ncvreg(temp_resultMat,
                                 input_group, 
                                 alpha=0.5, nfolds = nrow(temp_resultMat))
    
    temp_coefs <- coef(test_ncv_result)
    temp_coefs <- temp_coefs[temp_coefs != 0]
    temp_TSPs <- as.data.frame(list(geneA=unlist(lapply(names(temp_coefs)[-1], function(x) strsplit(x, "_")[[1]][1])),
                                    geneB=unlist(lapply(names(temp_coefs)[-1], function(x) strsplit(x, "_")[[1]][2])),
                                    coef=as.numeric(temp_coefs[-1])))
    
    ##Derive recommended probability cutoff
    all_TSPs <- c(temp_TSPs$geneA,temp_TSPs$geneB)
    sub_expr <- input_expression[rownames(input_expression) %in% all_TSPs,]
    temp_TSPs <- temp_TSPs[temp_TSPs$geneA %in% rownames(sub_expr) & temp_TSPs$geneB %in% rownames(sub_expr),]
    
    temp_resultMat <- list()
    for(temp_i in 1:nrow(temp_TSPs)){
        temp_name <- paste0(temp_TSPs$geneA[temp_i],"_",temp_TSPs$geneB[temp_i])
        temp_resultMat[[temp_name]] <- as.vector(as.integer(sub_expr[temp_TSPs$geneA[temp_i],] > sub_expr[temp_TSPs$geneB[temp_i],]))
    }
    temp_resultMat <- as.data.frame(temp_resultMat,row.names = colnames(sub_expr))
    
    ### p = exp(x*coef) / (1 + exp(x*coef))
    temp_resultVector <- rowSums(t(t(temp_resultMat) * temp_TSPs$coef))
    temp_resultProb <- exp(temp_resultVector) / (1 + exp(temp_resultVector))
    all_cutoff_values <- seq(1,99)/100
    min_errors <- length(input_group)
    for(temp_cutoff_i in 1:length(all_cutoff_values)){
        temp_cutoff_value <- all_cutoff_values[temp_cutoff_i]
        temp_table <- table(input_group,temp_resultProb > temp_cutoff_value)
        if(nrow(temp_table) == 2 & ncol(temp_table) == 2){
            temp_errors <- sum(temp_table[1,2] + temp_table[2,1])
            if(temp_errors < min_errors){
                min_errors <- temp_errors
                best_cutoffs <- c(temp_cutoff_value)
            }else if(temp_errors == min_errors){
                best_cutoffs <- c(best_cutoffs,temp_cutoff_value)
            }
        }
    }
    
    ##Return classifier
    temp_TSP_classifier <- list(intercept=as.numeric(temp_coefs[1]),TSPs=temp_TSPs,best_cutoff_probs=best_cutoffs)
    return(temp_TSP_classifier)
}


apply_TSP_classifier <- function(input_expression, input_classifier, use_with_missing=FALSE, best_cutoff_probability=NULL){
    
    if(is.null(best_cutoff_probability)){
        best_cutoff_probability <- input_classifier$best_cutoff_probs[1]
    }
    ##Check for missing classifier genes in input dataset with option to drop those pairs
    all_TSPs <- c(input_classifier$TSPs$geneA,input_classifier$TSPs$geneB)
    if(sum(all_TSPs %in% rownames(input_expression)) < length(all_TSPs)){
        missing_TSPs <- all_TSPs[!(all_TSPs %in% rownames(input_expression))]
        cat(paste0("The following genes were missing from the input dataset:\n",
                   paste(missing_TSPs,collapse=", ")))
        cat(paste0("Full input dataset:\n"))
        print(input_classifier$TSPs)
        
        if(use_with_missing==TRUE){
            classifier_rows_to_drop <- c()
            for(temp_i in 1:nrow(input_classifier$TSPs)){
                if(!(input_classifier$TSPs$geneA[temp_i] %in% rownames(input_expression)) | 
                   !(input_classifier$TSPs$geneB[temp_i] %in% rownames(input_expression))){
                    classifier_rows_to_drop <- c(classifier_rows_to_drop,temp_i)
                }
            }
            input_classifier <- input_classifier$TSPs[-classifier_rows_to_drop,]
        }else{
            return(paste0("Error: Failed due to missing classifier genes in the input data"))
        }
    }
    
    all_TSPs <- c(input_classifier$TSPs$geneA,input_classifier$TSPs$geneB)
    temp_expr <- input_expression[rownames(input_expression) %in% all_TSPs,]
    
    temp_resultMat <- list()
    for(temp_i in 1:nrow(input_classifier$TSPs)){
        temp_name <- paste0(input_classifier$TSPs[temp_i,1],"_",input_classifier$TSPs[temp_i,2])
        temp_resultMat[[temp_name]] <- as.vector(as.integer(temp_expr[input_classifier$TSPs[temp_i,1],] > temp_expr[input_classifier$TSPs[temp_i,2],]))
    }
    temp_resultMat <- as.data.frame(temp_resultMat,row.names = colnames(temp_expr))
    
    ### p = exp(x*coef) / (1 + exp(x*coef))
    temp_resultVector <- rowSums(t(t(temp_resultMat) * input_classifier$TSPs$coef))
    temp_resultProb <- exp(temp_resultVector) / (1 + exp(temp_resultVector))
    temp_resultGroup <- as.factor(as.numeric(temp_resultProb > best_cutoff_probability))
    
    temp_classifier_result <- as.data.frame(list(prob=temp_resultProb,group=temp_resultGroup))
    rownames(temp_classifier_result) <- colnames(input_expression)
    return(temp_classifier_result)
}

count2tpm<- function(rse){
    count_matrix <- rse@assays@data$raw_counts
    gene_length <- rse@rowRanges$bp_length
    reads_per_rpk <- count_matrix/gene_length
    per_mil_scale <- colSums(reads_per_rpk)/1000000
    tpm_matrix <- t(t(reads_per_rpk)/per_mil_scale)
    return(tpm_matrix)
}

getCountMatrix<- function(rse){
    count_matrix <- rse@assays@data$raw_counts
    return(count_matrix)
}

pullDataFromRecount3 <- function(input_project_name, input_project_source){
  
  human_projects <- available_projects()
  if(input_project_name %in% unique(human_projects$project) & input_project_source %in% unique(human_projects$file_source)){
    temp_project_info = subset(
      human_projects,
      project == input_project_name & file_source == input_project_source & project_type == "data_sources"
    )
    temp_info <- map(seq(nrow(temp_project_info)), ~temp_project_info[.x, ])
    ## create the RangedSummarizedExperiment. the create_rse function works on one row a time 
    temp_dataset <- map(temp_info, ~create_rse(.x))
    temp_tpm_data<- map(temp_dataset, count2tpm)
    temp_count_data <- map(temp_dataset, getCountMatrix)
    ## get the metadata column 
    temp_meta_data<- map(temp_dataset, ~.x@colData@listData %>% as.data.frame())
    # bind the data matrix across cancer types together 
    temp_tpms<- purrr::reduce(temp_tpm_data, cbind)
    temp_counts <- purrr::reduce(temp_count_data,cbind)
    ## bind the metadata across cancer types together
    temp_meta<- purrr::reduce(temp_meta_data, rbind)
    rownames(temp_meta) <- temp_meta$external_id
    ##Ensure idential ID naming across datasets and save them
    #rownames(temp_meta) <- temp_meta$tcga.gdc_cases.samples.submitter_id
    #colnames(temp_tpms) <- rownames(temp_meta)
    #colnames(temp_counts) <- rownames(temp_meta)
    temp_result <- list(meta=temp_meta,counts=temp_counts,tpms=temp_tpms)
    return(temp_result)
  }else{
    return(paste0("Error with input"))
  }
}

processRecount3Data_TCGA <- function(temp_result,filter_genes=FALSE){
  #Load expression and metadata files
  input_counts <- test_data$counts
  input_counts <- input_counts[,order(colnames(input_counts))]
  input_tpm <- test_data$tpms
  input_tpm <- input_tpm[,order(colnames(input_tpm))]
  input_meta <- test_data$meta
  input_meta <- input_meta[order(rownames(input_meta)),]
  
  ##Filter non-expressed genes
  if(filter_genes == TRUE){
    keep <- rowSums(input_counts > 0) > 0
    input_counts <- input_counts[keep,]
    input_tpm <- input_tpm[keep,]
  }
  
  ##Load and add survival and sample phenotype data to metadata
  input_surv <- read.table("E:/Projects/Cancer/TCGA_PanCancer_Survival_SupplementalTable_S1_20171025_xena_sp",sep="\t",header=TRUE,row.names=1)
  colnames(input_surv) <- paste0("Outcomes_",colnames(input_surv))
  input_extra <- read.table("E:/Projects/Cancer/TCGA_PanCancer_phenotype_denseDataOnlyDownload.tsv",sep="\t",header=TRUE,row.names=1)
  colnames(input_extra) <- paste0("SamplePhenotype_",colnames(input_extra))
  input_meta$Outcomes_matchingID <- unlist(lapply(input_meta$tcga.tcga_barcode,function(x){
    substr(paste0(str_split(x,"-")[[1]][1:4],collapse = "-"),
           1,nchar(paste0(str_split(x,"-")[[1]][1:4],collapse = "-")) - 1)
    }))
  input_meta <- cbind(input_meta,input_surv[input_meta$Outcomes_matchingID,],input_extra[input_meta$Outcomes_matchingID,])
  ##Reformat and factor primary sample type column used as covariate in modeling
  input_meta$sample_type <- input_meta$SamplePhenotype_sample_type
  input_meta$sample_type[input_meta$sample_type == "Primary Tumor"] <- "Tumor"
  input_meta$sample_type[input_meta$sample_type == "Metastatic"] <- "Met"
  input_meta$sample_type[input_meta$sample_type == "Solid Tissue Normal"] <- "Normal"
  input_meta$sample_type <- factor(input_meta$sample_type,levels=c("Normal","Tumor","Met"))
  ##Get HGNC symbols for remaining genes and replace ENSEMBL rownames
  gene_ids <- rownames(input_counts)
  
  # Remove version suffix if present
  gene_ids_clean <- sub("\\..*", "", gene_ids)
  # Connect to the Ensembl database
  # You can specify an Ensembl release if needed, e.g., useEnsembl(biomart="ensembl", 
  # version=109, dataset="hsapiens_gene_ensembl")
  symbol_map <- mapIds(
      x         = org.Hs.eg.db,
      keys      = gene_ids_clean,
      column    = "SYMBOL",     # We want HGNC gene symbols
      keytype   = "ENSEMBL",    # Our keys are Ensembl gene IDs
      multiVals = "first"       # If multiple symbols map to one ID, take the first
  )
  
  ##Replace ensembl IDs with symbols if not NA and not duplicated
  temp_rownames <- ifelse(
      is.na(symbol_map[gene_ids_clean]),
      gene_ids_clean,
      symbol_map[gene_ids_clean]
  )
  rownames(input_counts) <- ifelse(
      duplicated(temp_rownames),
      gene_ids_clean,
      temp_rownames
  )
  rownames(input_tpm) <- rownames(input_counts)
  
  if(all(colnames(input_counts) %in% rownames(input_meta)) & all(colnames(input_counts) == rownames(input_meta))){
    input_project_dataset <- list(meta=input_meta,log2TPM=log2(input_tpm+1))
    return(input_project_dataset)
  }else{
    return(paste0("Error with metadata and expression column numbers"))
  }
}

getMutCNV_data_TCGA <- function(input_project_name){
  query_maf <- GDCquery(
    project = input_project_name,
    data.category = "Simple Nucleotide Variation",
    data.type = "Masked Somatic Mutation",
    workflow.type = "Aliquot Ensemble Somatic Variant Merging and Masking"
  )
  GDCdownload(query_maf)
  maf_data <- GDCprepare(query_maf)
  query_cnv <- GDCquery(
    project = "TCGA-PAAD",
    data.category = "Copy Number Variation",
    data.type = "Copy Number Segment"
  )
  GDCdownload(query_cnv)
  cnv_data <- GDCprepare(query_cnv)
}

###

##Use recount3 to retrieve expression data for TCGA PAAD and normalize using different approaches


###Load necessary inputs

##Expression and metadata with outcome
test_data <- pullDataFromRecount3("PAAD","tcga")
test_data2 <- processRecount3Data_TCGA(test_data)

##Genesets

##scRNAseq



```

```{r explore GraphQL endpoint queries for utilization of RummaGEO}

library(ghql)
library(jsonlite)


client <- GraphqlClient$new(
    url = "https://rummageo.com/graphql"
)

qry <- Query$new()

test_query <- "ipsc neuro"

# Define your GraphQL query
# Here is a simple example retrieving a "name" field from a "me" object
my_query <- paste0('query MyQuery {
  geneSetTermSearch(terms: "',test_query,'") {
    edges {
      node {
        title
        term
        geneSetById {
          id
          genes {
            nodes {
              symbol
            }
          }
        }
      }
    }
  }
}
')

# Add the query to the Query object
qry$query('GetName', my_query)

# Execute the query
response <- client$exec(qry$queries$GetName)

# Parse the JSON response
parsed_response <- fromJSON(response)

# View the results
#head(parsed_response)

test_rummageo_result <- list(geneset_id=list(),geneset_title=list(),geneset_term=list(),geneset_genes=list())
##Geneset titles
test_rummageo_result$geneset_title <- parsed_response$data$geneSetTermSearch$edges$node$title
##Geneset ids
test_rummageo_result$geneset_id <- parsed_response$data$geneSetTermSearch$edges$node$geneSetById$id
##Geneset terms
test_rummageo_result$geneset_term <- parsed_response$data$geneSetTermSearch$edges$node$term
##Genes by geneset
test_rummageo_result$geneset_genes <- parsed_response$data$geneSetTermSearch$edges$node$geneSetById$genes$nodes


test_geneset <- c(test_classifier_result$TSPs$geneA,test_classifier_result$TSPs$geneB)

##

qry <- Query$new()

test_query <- "ipsc neuro"

# Define your GraphQL query
# Here is a simple example retrieving a "name" field from a "me" object
my_query <- paste0('query MyQuery {
  geneSetTermSearch(terms: "',test_query,'") {
    edges {
      node {
        title
        term
        geneSetById {
          id
          genes {
            nodes {
              symbol
            }
          }
        }
      }
    }
  }
}
')

# Add the query to the Query object
qry$query('GetName', my_query)

# Execute the query
response <- client$exec(qry$queries$GetName)

# Parse the JSON response
parsed_response <- fromJSON(response)

# View the results
#head(parsed_response)

test_rummageo_result <- list(geneset_id=list(),geneset_title=list(),geneset_term=list(),geneset_genes=list())

##Geneset titles
test_rummageo_result$geneset_title <- parsed_response$data$geneSetTermSearch$edges$node$title

##Geneset ids
test_rummageo_result$geneset_id <- parsed_response$data$geneSetTermSearch$edges$node$geneSetById$id

##Geneset terms
test_rummageo_result$geneset_term <- parsed_response$data$geneSetTermSearch$edges$node$term

##Genes by geneset
test_rummageo_result$geneset_genes <- parsed_response$data$geneSetTermSearch$edges$node$geneSetById$genes$nodes



```


Add a new chunk by clicking the *Insert Chunk* button on the toolbar or by pressing *Ctrl+Alt+I*.

When you save the notebook, an HTML file containing the code and output will be saved alongside it (click the *Preview* button or press *Ctrl+Shift+K* to preview the HTML file).

The preview shows you a rendered HTML copy of the contents of the editor. Consequently, unlike *Knit*, *Preview* does not run any R code chunks. Instead, the output of the chunk when it was last run in the editor is displayed.
